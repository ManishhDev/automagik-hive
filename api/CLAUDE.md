# API Directory - FastAPI Application and Endpoints

<system_context>
This directory contains the FastAPI application, API endpoints, and request/response handling for the PagBank multi-agent system. All API interactions follow Agno framework patterns for agent and team management, with comprehensive support for streaming responses, dynamic versioning, and PostgreSQL storage integration.
</system_context>

## API Architecture Principles

### Agno-First Design ✅ VERIFIED
All endpoints are built using Agno's built-in FastAPI integration:
- **Automatic Registration**: Agents, teams, and workflows auto-register via `FastAPIApp()` and `Playground()`
- **Built-in Session Management**: PostgreSQL/SQLite sessions with automatic schema management
- **Streaming Response Support**: Server-Sent Events (SSE) and WebSocket support
- **Storage Integration**: Automatic PostgreSQL failover to SQLite
- **Playground Router**: Complete UI via `get_playground_router()` pattern

### Dynamic Agent Management ✅ ENHANCED
The API supports dynamic agent versioning without file system changes:
- **Version-Specific Runs**: `POST /v1/agents/pagbank/runs?version=27`
- **Latest Version Access**: `GET /v1/agents/pagbank` (defaults to latest)
- **Version Listing**: `GET /v1/agents/pagbank/versions`
- **Team-Level Versioning**: `POST /v1/teams/ana/runs` with member version control
- **Database-Driven Config**: Hot-reload via API updates, no file system changes

### FastAPI Application Structure ✅ FROM DEMO APP
Based on `genie/agno-demo-app/api/` patterns:
```python
# api/main.py (FastAPI factory pattern)
def create_app() -> FastAPI:
    app = FastAPI(
        title="PagBank Multi-Agent System",
        version="2.0.0",
        docs_url="/docs" if settings.docs_enabled else None,
        redoc_url="/redoc" if settings.docs_enabled else None,
    )
    
    # Add router hierarchy
    app.include_router(v1_router)
    
    # CORS middleware for playground integration
    app.add_middleware(
        CORSMiddleware,
        allow_origins=settings.cors_origins,
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    return app
```

## Router Architecture ✅ EXTRACTED FROM DEMO APP

### V1 API Router Structure
```python
# api/routes/v1_router.py (copied from demo app)
from fastapi import APIRouter
from api.routes.playground import playground_router
from api.routes.health import health_router

v1_router = APIRouter(prefix="/v1")
v1_router.include_router(playground_router)  # Agno playground integration
v1_router.include_router(health_router)     # Health checks
```

### Playground Router Integration ✅ COMPREHENSIVE
```python
# api/routes/playground.py (based on demo app pattern)
from agno.playground import Playground

# Import PagBank components
from agents.pagbank.agent import get_pagbank_agent
from agents.adquirencia.agent import get_adquirencia_agent
from agents.emissao.agent import get_emissao_agent
from teams.ana.team import get_ana_team
from workflows.human_handoff import get_human_handoff_workflow

# Create agents with debug mode
pagbank_agent = get_pagbank_agent(debug_mode=True)
adquirencia_agent = get_adquirencia_agent(debug_mode=True)
emissao_agent = get_emissao_agent(debug_mode=True)

# Create Ana routing team
ana_team = get_ana_team()

# Create workflows
human_handoff_workflow = get_human_handoff_workflow(debug_mode=True)

# Create playground instance (auto-registers all endpoints)
playground = Playground(
    agents=[pagbank_agent, adquirencia_agent, emissao_agent],
    teams=[ana_team],
    workflows=[human_handoff_workflow],
)

# Register with Agno platform (development only)
if getenv("RUNTIME_ENV") == "dev":
    playground.register_app_on_platform()

# Get router with all endpoints
playground_router = playground.get_router()
```

## Core API Endpoints ✅ AGNO AUTO-GENERATED

### Agent Endpoints (Auto-Generated by Playground)
```http
# Individual agent interactions (via Agno Playground)
POST /v1/agents/{agent_id}/runs
GET  /v1/agents/{agent_id}/sessions
POST /v1/agents/{agent_id}/sessions/{session_id}/runs
GET  /v1/agents/{agent_id}/versions
POST /v1/agents/{agent_id}/versions/{version}/runs

# PagBank specialist agents
POST /v1/agents/pagbank-specialist/runs
POST /v1/agents/adquirencia-specialist/runs  
POST /v1/agents/emissao-specialist/runs
POST /v1/agents/human-handoff-specialist/runs
```

### Team Endpoints (Auto-Generated by Playground)
```http
# Ana team (main customer assistant)
POST /v1/teams/ana-pagbank-assistant/runs
GET  /v1/teams/ana-pagbank-assistant/members
POST /v1/teams/ana-pagbank-assistant/sessions/{session_id}/runs
GET  /v1/teams/ana-pagbank-assistant/sessions

# Team routing with mode="route" (auto-handled by Agno)
POST /v1/teams/ana-pagbank-assistant/route
```

### Workflow Endpoints (Auto-Generated by Playground)
```http
# Human handoff workflow (typification + escalation)
POST /v1/workflows/human-handoff/runs
GET  /v1/workflows/human-handoff/status/{run_id}
POST /v1/workflows/human-handoff/sessions/{session_id}/runs

# Future workflows (when implemented)
POST /v1/workflows/typification/runs
POST /v1/workflows/compliance/runs
```

### Health & Monitoring Endpoints ✅ FROM DEMO APP
```http
# Health checks (copied from demo app pattern)
GET /v1/health
GET /health

# Playground UI (auto-generated)
GET /playground
GET /docs          # OpenAPI documentation
GET /redoc         # ReDoc documentation
```

## Request/Response Patterns ✅ ENHANCED WITH AGNO PARAMETERS

### Standard Chat Request ✅ VERIFIED PARAMETERS
```json
{
  "messages": [
    {
      "role": "user", 
      "content": "Como faço um PIX?"
    }
  ],
  "session_id": "user-123-session-456",
  "user_id": "customer-789",
  "stream": true,
  "language": "pt-BR",
  "model_override": {
    "id": "claude-sonnet-4-20250514",
    "temperature": 0.7,
    "max_tokens": 2000
  },
  "debug_mode": true,
  "add_context": true,
  "enable_agentic_memory": true
}
```

### Agent Response ✅ COMPREHENSIVE METADATA
```json
{
  "run_id": "run-abc123",
  "agent_id": "pagbank-specialist",
  "agent_name": "PagBank Digital Banking Specialist",
  "version": 27,
  "content": "Para fazer um PIX...",
  "thinking": "User is asking about PIX transfers...",
  "metadata": {
    "business_unit": "PagBank",
    "escalation_triggered": false,
    "suggested_actions": ["check_pix_limits", "view_pix_keys"],
    "tools_used": ["search_knowledge_base"],
    "session_id": "user-123-session-456",
    "model_used": "claude-sonnet-4-20250514",
    "tokens_used": 1247,
    "response_time_ms": 1850
  },
  "references": [
    {
      "source": "knowledge_rag.csv",
      "title": "PIX Transfer Limits",
      "url": "internal://pix-limits"
    }
  ]
}
```

### Team Routing Response ✅ MODE="ROUTE" PATTERN
```json
{
  "run_id": "run-def456",
  "team_id": "ana-pagbank-assistant",
  "team_name": "Ana - Atendimento PagBank", 
  "mode": "route",
  "routed_to_agent": "pagbank-specialist",
  "routing_reason": "PIX query detected - business unit match",
  "content": "Para fazer um PIX...",
  "metadata": {
    "routing_confidence": 0.95,
    "business_unit": "PagBank",
    "routing_keywords": ["pix", "transferência"],
    "team_members_evaluated": [
      "pagbank-specialist",
      "adquirencia-specialist", 
      "emissao-specialist",
      "human-handoff-specialist"
    ],
    "agent_selection_reasoning": "Query contains PIX-related keywords, matches PagBank specialist expertise"
  }
}
```

### Workflow Response ✅ WORKFLOW PATTERN
```json
{
  "run_id": "run-workflow-123",
  "workflow_id": "human-handoff",
  "workflow_name": "Human Handoff Workflow",
  "status": "completed",
  "steps_completed": [
    {
      "step_id": "frustration_detection",
      "agent_id": "human-handoff-specialist",
      "output": "Frustration level: 3/5 - escalation triggered"
    },
    {
      "step_id": "ticket_generation",
      "agent_id": "ticketing_agent",
      "output": "Ticket #TKT-2025-001234 created"
    }
  ],
  "final_output": {
    "ticket_id": "TKT-2025-001234",
    "escalation_type": "human_agent",
    "priority": "high",
    "estimated_wait_time": "5-10 minutes"
  }
}
```

### Error Response ✅ STANDARDIZED FORMAT
```json
{
  "error": {
    "code": "AGENT_NOT_FOUND",
    "message": "Agent 'invalid-agent' not found",
    "details": {
      "available_agents": [
        "pagbank-specialist",
        "adquirencia-specialist", 
        "emissao-specialist",
        "human-handoff-specialist"
      ],
      "suggested_team": "ana-pagbank-assistant"
    }
  },
  "request_id": "req-123456",
  "timestamp": "2025-01-12T15:30:45Z"
}
```

## Streaming Implementation ✅ AGNO NATIVE SUPPORT

### Server-Sent Events (SSE) ✅ EXTRACTED FROM PATTERNS
```python
# Agno automatically handles streaming via run_stream()
@app.post("/v1/agents/{agent_id}/runs/stream")
async def stream_agent_response(request: ChatRequest):
    agent = get_agent(request.agent_id, version=request.version)
    
    async def generate():
        # Agno's native streaming support
        async for chunk in agent.run_stream(
            messages=request.messages,
            session_id=request.session_id,
            stream=True,  # Enable streaming mode
            stream_intermediate_steps=True  # Show tool calls in real-time
        ):
            # Agno RunResponse format
            yield f"data: {json.dumps({
                'content': chunk.content,
                'metadata': chunk.metadata,
                'run_id': chunk.run_id,
                'agent_id': chunk.agent_id,
                'thinking': getattr(chunk, 'thinking', None),  # Claude thinking mode
                'tools_used': chunk.metadata.get('tools_used', [])
            })}\n\n"
    
    return StreamingResponse(
        generate(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "Access-Control-Allow-Origin": "*"
        }
    )
```

### Team Streaming ✅ MODE="ROUTE" STREAMING
```python
@app.post("/v1/teams/{team_id}/runs/stream")
async def stream_team_response(request: TeamChatRequest):
    team = get_team(request.team_id)
    
    async def generate():
        # Team with mode="route" streams the selected agent's response
        async for chunk in team.run_stream(
            messages=request.messages,
            session_id=request.session_id,
            stream=True,
            show_members_responses=False,  # Hide member selection in stream
            stream_intermediate_steps=request.stream_intermediate_steps
        ):
            yield f"data: {json.dumps({
                'content': chunk.content,
                'routed_to_agent': chunk.metadata.get('routed_to_agent'),
                'routing_reason': chunk.metadata.get('routing_reason'),
                'team_id': chunk.team_id,
                'run_id': chunk.run_id
            })}\n\n"
    
    return StreamingResponse(generate(), media_type="text/event-stream")
```

### WebSocket Support ✅ ENHANCED PROTOCOL
```python
@app.websocket("/v1/ws/{session_id}")
async def websocket_endpoint(websocket: WebSocket, session_id: str):
    await websocket.accept()
    
    try:
        while True:
            data = await websocket.receive_json()
            
            if data["type"] == "agent_query":
                agent = get_agent(data["agent_id"])
                async for response in agent.run_stream(
                    messages=[{"role": "user", "content": data["message"]}],
                    session_id=session_id,
                    stream=True
                ):
                    await websocket.send_json({
                        "type": "agent_response",
                        "data": response.dict()
                    })
                    
            elif data["type"] == "team_query":
                team = get_team(data["team_id"])
                async for response in team.run_stream(
                    messages=[{"role": "user", "content": data["message"]}],
                    session_id=session_id,
                    stream=True
                ):
                    await websocket.send_json({
                        "type": "team_response", 
                        "data": response.dict()
                    })
                    
    except WebSocketDisconnect:
        print(f"WebSocket disconnected for session: {session_id}")
```

### Streaming Configuration ✅ AGNO PARAMETERS
```python
# Enable streaming in agent/team configuration
agent = Agent(
    name="PagBank Specialist",
    stream=True,  # Enable streaming by default
    stream_intermediate_steps=True,  # Show tool calls
    markdown=True,  # Enable markdown formatting in streams
)

team = Team(
    name="Ana Team",
    mode="route",
    stream=True,  # Enable team-level streaming
    stream_intermediate_steps=False,  # Hide routing decision process
    show_members_responses=False,  # Hide member selection in UI
)
```

## Authentication & Security ✅ EXTRACTED FROM DEMO APP

### Environment-Based Authentication ✅ FROM SETTINGS
```python
# api/settings.py (copied from demo app pattern)
from pydantic_settings import BaseSettings
from typing import List, Optional

class ApiSettings(BaseSettings):
    """API settings configurable via environment variables"""
    
    # API identification
    title: str = "PagBank Multi-Agent System"
    version: str = "2.0.0"
    
    # Runtime environment: dev, stg, prd
    runtime_env: str = "dev"
    
    # Security settings
    docs_enabled: bool = True  # Disable in production
    api_key_required: bool = False  # Enable for production
    
    # CORS configuration
    cors_origins: Optional[List[str]] = None
    
    @field_validator("cors_origins", mode="before") 
    def set_cors_origins(cls, cors_origins, info):
        """Auto-configure CORS based on environment"""
        valid_cors = cors_origins or []
        
        if info.data.get("runtime_env") == "dev":
            valid_cors.extend([
                "http://localhost:3000",
                "http://localhost:7777",
                "https://app.agno.com",
                "https://app-stg.agno.com"
            ])
        elif info.data.get("runtime_env") == "prd":
            valid_cors.extend([
                "https://pagbank.com.br",
                "https://app.pagbank.com.br"
            ])
        
        return valid_cors

api_settings = ApiSettings()
```

### API Key Authentication ✅ PRODUCTION READY
```python
@app.middleware("http")
async def authenticate_request(request: Request, call_next):
    # Skip authentication in development
    if api_settings.runtime_env == "dev":
        return await call_next(request)
    
    # Skip authentication for health checks
    if request.url.path in ["/health", "/v1/health"]:
        return await call_next(request)
    
    # Require API key for production
    if api_settings.api_key_required:
        api_key = request.headers.get("X-API-Key")
        if not validate_api_key(api_key):
            return JSONResponse(
                status_code=401,
                content={
                    "error": "Invalid API key",
                    "details": "Contact PagBank support for API access"
                }
            )
    
    return await call_next(request)

def validate_api_key(api_key: str) -> bool:
    """Validate API key against environment configuration"""
    if not api_key:
        return False
    
    # Check against configured API keys
    valid_keys = os.getenv("PAGBANK_API_KEYS", "").split(",")
    return api_key.strip() in [key.strip() for key in valid_keys if key.strip()]
```

### Rate Limiting ✅ COMPREHENSIVE PROTECTION
```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

# Create limiter with user identification
limiter = Limiter(
    key_func=lambda request: (
        request.headers.get("X-User-ID", get_remote_address(request))
    ),
    default_limits=["1000/hour"]  # Global limit
)

# Add rate limit handler
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# Agent endpoint limits (business critical)
@app.post("/v1/agents/{agent_id}/runs")
@limiter.limit("100/minute")  # High limit for agent interactions
async def run_agent(request: ChatRequest):
    pass

# Team endpoint limits (main entry point)
@app.post("/v1/teams/{team_id}/runs") 
@limiter.limit("200/minute")  # Higher limit for team routing
async def run_team(request: TeamChatRequest):
    pass

# Workflow limits (resource intensive)
@app.post("/v1/workflows/{workflow_id}/runs")
@limiter.limit("20/minute")  # Lower limit for complex workflows
async def run_workflow(request: WorkflowRequest):
    pass
```

### Security Headers ✅ COMPREHENSIVE
```python
@app.middleware("http")
async def security_headers(request: Request, call_next):
    response = await call_next(request)
    
    # Security headers for production
    if api_settings.runtime_env == "prd":
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-XSS-Protection"] = "1; mode=block"
        response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
        response.headers["Content-Security-Policy"] = "default-src 'self'"
    
    return response
```

## Environment Configuration ✅ COMPREHENSIVE SETTINGS

### Environment Variables ✅ FROM REFERENCE
```bash
# Core application settings
PB_AGENTS_HOST="0.0.0.0"              # API host (extracted from serve.py)
PB_AGENTS_PORT="8000"                 # API port (extracted from serve.py)
RUNTIME_ENV="dev"                     # Environment: dev, stg, prd

# Database configuration (auto-fallback to SQLite)
DATABASE_URL="postgresql://ai:ai@localhost:5532/ai"

# Model API keys (from agno-advanced-patterns.md)
ANTHROPIC_API_KEY="sk-ant-..."        # Required for Claude models
OPENAI_API_KEY="sk-..."               # Optional for OpenAI models
WHATSAPP_API_KEY="..."                # Required for human handoff

# Security & Rate limiting
PAGBANK_API_KEYS="key1,key2,key3"    # Comma-separated API keys
API_KEY_REQUIRED="false"              # Set to "true" in production

# Agno-specific settings
AGNO_MONITOR="true"                   # Enable monitoring (from advanced patterns)
AGNO_TELEMETRY="true"                # Enable telemetry
```

### Development Environment ✅ ENHANCED
```python
# api/settings.py (comprehensive development config)
class DevelopmentSettings(ApiSettings):
    runtime_env: str = "dev"
    
    # Debug settings
    debug_mode: bool = True
    docs_enabled: bool = True          # Enable /docs and /redoc
    log_level: str = "DEBUG"
    
    # Database (auto-fallback to SQLite)
    database_url: str = "postgresql://ai:ai@localhost:5532/ai"
    auto_upgrade_schema: bool = True
    
    # Security (relaxed for dev)
    api_key_required: bool = False
    cors_origins: List[str] = [
        "http://localhost:3000",
        "http://localhost:7777",
        "https://app.agno.com",
        "*"  # Allow all in development
    ]
    
    # Playground settings
    enable_playground: bool = True
    playground_register: bool = True   # Register with Agno platform
    
    # Rate limiting (generous for dev)
    rate_limit_global: str = "10000/hour"
    rate_limit_agents: str = "1000/minute"
    rate_limit_teams: str = "2000/minute"
```

### Production Environment ✅ SECURE DEFAULTS
```python
class ProductionSettings(ApiSettings):
    runtime_env: str = "prd"
    
    # Security settings
    debug_mode: bool = False
    docs_enabled: bool = False         # Disable API docs in production
    log_level: str = "INFO"
    
    # Database (production PostgreSQL required)
    database_url: str = Field(..., env="DATABASE_URL")  # Required in production
    auto_upgrade_schema: bool = False  # Manual schema management
    
    # Security (strict for production)
    api_key_required: bool = True
    cors_origins: List[str] = [
        "https://pagbank.com.br",
        "https://app.pagbank.com.br"
    ]
    
    # Playground settings
    enable_playground: bool = False    # Disable playground in production
    playground_register: bool = False
    
    # Rate limiting (strict for production)
    rate_limit_global: str = "1000/hour"
    rate_limit_agents: str = "100/minute"
    rate_limit_teams: str = "200/minute"
    rate_limit_workflows: str = "20/minute"
    
    # Health check configuration
    health_check_timeout: int = 30
    database_pool_size: int = 20
    database_max_overflow: int = 40

# Auto-select environment based on RUNTIME_ENV
def get_settings() -> ApiSettings:
    env = os.getenv("RUNTIME_ENV", "dev")
    if env == "prd":
        return ProductionSettings()
    elif env == "stg":
        return StagingSettings()
    else:
        return DevelopmentSettings()

api_settings = get_settings()
```

### Staging Environment ✅ MIDDLE GROUND
```python
class StagingSettings(ApiSettings):
    runtime_env: str = "stg"
    
    # Balanced settings for staging
    debug_mode: bool = True            # Enable debug for testing
    docs_enabled: bool = True          # Keep docs for testing
    log_level: str = "INFO"
    
    # Database (staging PostgreSQL)
    database_url: str = Field(..., env="DATABASE_URL")
    auto_upgrade_schema: bool = True   # Allow schema changes in staging
    
    # Security (moderate for staging)
    api_key_required: bool = True
    cors_origins: List[str] = [
        "https://stg.pagbank.com.br",
        "https://app-stg.agno.com"
    ]
    
    # Playground settings
    enable_playground: bool = True     # Enable for testing
    playground_register: bool = True
    
    # Rate limiting (moderate for staging)
    rate_limit_global: str = "5000/hour"
    rate_limit_agents: str = "500/minute"
    rate_limit_teams: str = "1000/minute"
```

## Error Handling ✅ COMPREHENSIVE ERROR MANAGEMENT

### Standard Error Response ✅ ENHANCED FORMAT
```json
{
  "error": {
    "code": "AGENT_NOT_FOUND",
    "message": "Agent 'invalid-agent' not found",
    "details": {
      "available_agents": [
        "pagbank-specialist",
        "adquirencia-specialist", 
        "emissao-specialist",
        "human-handoff-specialist"
      ],
      "suggested_team": "ana-pagbank-assistant",
      "endpoint_suggestion": "/v1/teams/ana-pagbank-assistant/runs"
    }
  },
  "request_id": "req-123456",
  "timestamp": "2025-01-12T15:30:45Z",
  "trace_id": "trace-abc-def-123"  # For debugging
}
```

### Error Categories ✅ COMPLETE TAXONOMY
```python
class APIErrorCodes:
    # Agent errors
    AGENT_NOT_FOUND = "AGENT_NOT_FOUND"
    AGENT_VERSION_NOT_FOUND = "AGENT_VERSION_NOT_FOUND"
    AGENT_INITIALIZATION_FAILED = "AGENT_INITIALIZATION_FAILED"
    
    # Team errors
    TEAM_NOT_FOUND = "TEAM_NOT_FOUND"
    TEAM_ROUTING_FAILED = "TEAM_ROUTING_FAILED"
    TEAM_MEMBER_UNAVAILABLE = "TEAM_MEMBER_UNAVAILABLE"
    
    # Workflow errors
    WORKFLOW_NOT_FOUND = "WORKFLOW_NOT_FOUND"
    WORKFLOW_EXECUTION_FAILED = "WORKFLOW_EXECUTION_FAILED"
    WORKFLOW_STEP_FAILED = "WORKFLOW_STEP_FAILED"
    
    # Session & State errors
    SESSION_EXPIRED = "SESSION_EXPIRED"
    SESSION_NOT_FOUND = "SESSION_NOT_FOUND"
    INVALID_SESSION_STATE = "INVALID_SESSION_STATE"
    
    # Security & Rate limiting
    AUTHENTICATION_FAILED = "AUTHENTICATION_FAILED"
    AUTHORIZATION_FAILED = "AUTHORIZATION_FAILED"
    RATE_LIMIT_EXCEEDED = "RATE_LIMIT_EXCEEDED"
    
    # Validation errors
    VALIDATION_ERROR = "VALIDATION_ERROR"
    INVALID_REQUEST_FORMAT = "INVALID_REQUEST_FORMAT"
    MISSING_REQUIRED_FIELD = "MISSING_REQUIRED_FIELD"
    
    # Database & Storage errors
    DATABASE_CONNECTION_FAILED = "DATABASE_CONNECTION_FAILED"
    STORAGE_OPERATION_FAILED = "STORAGE_OPERATION_FAILED"
    
    # Model & Provider errors
    MODEL_API_ERROR = "MODEL_API_ERROR"
    MODEL_QUOTA_EXCEEDED = "MODEL_QUOTA_EXCEEDED"
    MODEL_TIMEOUT = "MODEL_TIMEOUT"
    
    # Business logic errors
    BUSINESS_UNIT_ROUTING_FAILED = "BUSINESS_UNIT_ROUTING_FAILED"
    KNOWLEDGE_BASE_UNAVAILABLE = "KNOWLEDGE_BASE_UNAVAILABLE"
    COMPLIANCE_VALIDATION_FAILED = "COMPLIANCE_VALIDATION_FAILED"
```

### Error Handler Implementation ✅ PRODUCTION READY
```python
from fastapi import HTTPException, Request
from fastapi.responses import JSONResponse
import traceback
import uuid

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    """Global exception handler with comprehensive error details"""
    
    # Generate trace ID for debugging
    trace_id = str(uuid.uuid4())
    
    # Log error with full context
    logger.error(f"Global exception: {exc}", extra={
        "trace_id": trace_id,
        "request_path": request.url.path,
        "request_method": request.method,
        "user_id": request.headers.get("X-User-ID"),
        "traceback": traceback.format_exc()
    })
    
    # Determine error code and message
    if isinstance(exc, HTTPException):
        error_code = "HTTP_ERROR"
        message = exc.detail
        status_code = exc.status_code
    elif "agent" in str(exc).lower():
        error_code = "AGENT_ERROR"
        message = "Agent processing failed"
        status_code = 500
    elif "database" in str(exc).lower():
        error_code = "DATABASE_ERROR"
        message = "Database operation failed"
        status_code = 503
    else:
        error_code = "INTERNAL_SERVER_ERROR"
        message = "An unexpected error occurred"
        status_code = 500
    
    # Hide sensitive details in production
    details = {}
    if api_settings.runtime_env == "dev":
        details["exception_type"] = type(exc).__name__
        details["exception_message"] = str(exc)
        details["traceback_summary"] = traceback.format_exc().split('\n')[-3:-1]
    
    return JSONResponse(
        status_code=status_code,
        content={
            "error": {
                "code": error_code,
                "message": message,
                "details": details
            },
            "request_id": str(uuid.uuid4()),
            "trace_id": trace_id,
            "timestamp": datetime.utcnow().isoformat() + "Z"
        }
    )
```

## Monitoring & Observability ✅ COMPREHENSIVE MONITORING

### Health Check Endpoint ✅ FROM DEMO APP
```python
# api/routes/health.py (copied from demo app)
from fastapi import APIRouter
from utils.dttm import current_utc_str

health_router = APIRouter(tags=["Health"])

@health_router.get("/health")
async def get_health():
    """Check the health of the API"""
    
    # Basic health check
    health_status = {
        "status": "healthy",
        "router": "health",
        "path": "/health",
        "utc": current_utc_str(),
        "version": "2.0.0",
        "runtime_env": api_settings.runtime_env
    }
    
    # Enhanced health checks for production
    if api_settings.runtime_env in ["stg", "prd"]:
        health_status.update({
            "database": await check_database_connection(),
            "agents": await check_agent_availability(),
            "models": await check_model_api_status(),
            "knowledge_base": await check_knowledge_base_status()
        })
    
    return health_status

async def check_database_connection() -> dict:
    """Check PostgreSQL/SQLite connection status"""
    try:
        # Test database connection
        from config.postgres_config import get_postgres_storage
        storage = get_postgres_storage()
        if storage:
            # Perform simple query
            return {"status": "connected", "type": "postgresql"}
        else:
            return {"status": "connected", "type": "sqlite"}
    except Exception as e:
        return {"status": "error", "error": str(e)}

async def check_agent_availability() -> dict:
    """Check if all agents can be instantiated"""
    try:
        from agents.orchestrator.main_orchestrator import create_main_orchestrator
        orchestrator = create_main_orchestrator()
        return {
            "status": "available",
            "agent_count": len(orchestrator.specialist_agents),
            "agents": list(orchestrator.specialist_agents.keys())
        }
    except Exception as e:
        return {"status": "error", "error": str(e)}
```

### Metrics Integration ✅ AGNO NATIVE MONITORING
```python
# Agno has built-in monitoring - enable via environment
# AGNO_MONITOR="true" AGNO_TELEMETRY="true"

from prometheus_client import Counter, Histogram, Gauge
import time

# API-level metrics
REQUEST_COUNT = Counter(
    'pagbank_api_requests_total', 
    'Total API requests',
    ['method', 'endpoint', 'status_code']
)

REQUEST_DURATION = Histogram(
    'pagbank_api_request_duration_seconds',
    'Request duration in seconds',
    ['endpoint', 'method']
)

ACTIVE_SESSIONS = Gauge(
    'pagbank_active_sessions',
    'Number of active user sessions'
)

AGENT_REQUESTS = Counter(
    'pagbank_agent_requests_total',
    'Total agent requests',
    ['agent_id', 'business_unit']
)

TEAM_ROUTING_DECISIONS = Counter(
    'pagbank_team_routing_total',
    'Team routing decisions',
    ['team_id', 'routed_to_agent', 'routing_reason']
)

@app.middleware("http")
async def metrics_middleware(request: Request, call_next):
    """Comprehensive metrics collection"""
    start_time = time.time()
    
    # Extract endpoint for metrics
    endpoint = request.url.path
    method = request.method
    
    try:
        response = await call_next(request)
        status_code = response.status_code
        
        # Record successful request
        REQUEST_COUNT.labels(
            method=method,
            endpoint=endpoint,
            status_code=status_code
        ).inc()
        
        REQUEST_DURATION.labels(
            endpoint=endpoint,
            method=method
        ).observe(time.time() - start_time)
        
        return response
        
    except Exception as e:
        # Record failed request
        REQUEST_COUNT.labels(
            method=method,
            endpoint=endpoint,
            status_code=500
        ).inc()
        
        REQUEST_DURATION.labels(
            endpoint=endpoint,
            method=method
        ).observe(time.time() - start_time)
        
        raise e

# Business metrics tracking
@app.middleware("http")
async def business_metrics_middleware(request: Request, call_next):
    """Track business-specific metrics"""
    response = await call_next(request)
    
    # Track agent requests
    if "/agents/" in request.url.path and request.method == "POST":
        agent_id = request.path_params.get("agent_id", "unknown")
        business_unit = get_business_unit_from_agent(agent_id)
        AGENT_REQUESTS.labels(
            agent_id=agent_id,
            business_unit=business_unit
        ).inc()
    
    # Track team routing
    if "/teams/" in request.url.path and request.method == "POST":
        team_id = request.path_params.get("team_id", "unknown")
        # Extract routing metadata from response if available
        # This would be populated by the team routing logic
        
    return response

# Prometheus metrics endpoint
@app.get("/metrics")
async def metrics():
    """Prometheus metrics endpoint"""
    from prometheus_client import generate_latest, CONTENT_TYPE_LATEST
    return Response(generate_latest(), media_type=CONTENT_TYPE_LATEST)
```

### Performance Monitoring ✅ ENHANCED TRACKING
```python
import asyncio
from typing import Dict, Any
import psutil
import logging

# Performance monitoring
class PerformanceMonitor:
    def __init__(self):
        self.metrics = {}
        self.logger = logging.getLogger("performance")
    
    async def track_system_metrics(self):
        """Track system-level performance metrics"""
        while True:
            try:
                # System metrics
                cpu_percent = psutil.cpu_percent()
                memory = psutil.virtual_memory()
                disk = psutil.disk_usage('/')
                
                # Application metrics
                active_sessions = await self.count_active_sessions()
                agent_response_times = await self.get_agent_response_times()
                
                self.metrics.update({
                    "system": {
                        "cpu_percent": cpu_percent,
                        "memory_percent": memory.percent,
                        "memory_available_gb": memory.available / (1024**3),
                        "disk_percent": disk.percent,
                        "disk_free_gb": disk.free / (1024**3)
                    },
                    "application": {
                        "active_sessions": active_sessions,
                        "agent_avg_response_time": agent_response_times,
                        "timestamp": datetime.utcnow().isoformat()
                    }
                })
                
                # Log performance alerts
                if cpu_percent > 80:
                    self.logger.warning(f"High CPU usage: {cpu_percent}%")
                if memory.percent > 85:
                    self.logger.warning(f"High memory usage: {memory.percent}%")
                
                await asyncio.sleep(60)  # Check every minute
                
            except Exception as e:
                self.logger.error(f"Performance monitoring error: {e}")
                await asyncio.sleep(60)

# Start performance monitoring
monitor = PerformanceMonitor()

@app.on_event("startup")
async def start_monitoring():
    """Start background monitoring tasks"""
    if api_settings.runtime_env in ["stg", "prd"]:
        asyncio.create_task(monitor.track_system_metrics())
```

## Integration Patterns ✅ COMPREHENSIVE AGNO INTEGRATION

### Agno Playground Integration ✅ ENHANCED FROM DEMO APP
```python
# api/routes/playground.py (comprehensive pattern)
from agno.playground import Playground
from os import getenv

# Import all PagBank components
from agents.pagbank.agent import get_pagbank_agent
from agents.adquirencia.agent import get_adquirencia_agent 
from agents.emissao.agent import get_emissao_agent
from agents.human_handoff.agent import get_human_handoff_agent
from teams.ana.team import get_ana_team
from workflows.human_handoff import get_human_handoff_workflow
from workflows.typification import get_typification_workflow

# Create agents with debug mode for development
pagbank_agent = get_pagbank_agent(debug_mode=True)
adquirencia_agent = get_adquirencia_agent(debug_mode=True)
emissao_agent = get_emissao_agent(debug_mode=True)
human_handoff_agent = get_human_handoff_agent(debug_mode=True)

# Create Ana routing team (main entry point)
ana_team = get_ana_team()

# Create workflows
human_handoff_workflow = get_human_handoff_workflow(debug_mode=True)
typification_workflow = get_typification_workflow(debug_mode=True)

# Create comprehensive playground
playground = Playground(
    agents=[
        pagbank_agent, 
        adquirencia_agent, 
        emissao_agent,
        human_handoff_agent
    ],
    teams=[ana_team],
    workflows=[
        human_handoff_workflow,
        typification_workflow
    ],
    app_id="pagbank-multi-agent-system",
    name="PagBank Multi-Agent System"
)

# Register with Agno platform (development only)
if getenv("RUNTIME_ENV") == "dev":
    playground.register_app_on_platform()

# Get FastAPI router with all endpoints
playground_router = playground.get_router()
```

### Database Session Management ✅ POSTGRES + SQLITE PATTERN
```python
# Agno handles storage automatically with fallback
from agno.storage.postgresql import PostgresStorage
from config.postgres_config import get_postgres_storage

def setup_storage_for_components():
    """Setup storage for all agents, teams, and workflows"""
    
    # Get PostgreSQL storage with automatic SQLite fallback
    postgres_storage = get_postgres_storage(mode="universal")
    
    if postgres_storage:
        print("✅ Using PostgreSQL storage for all components")
        storage_config = {
            "provider": "postgresql",
            "db_url": postgres_storage.db_url,
            "auto_upgrade_schema": True
        }
    else:
        print("ℹ️ Using SQLite storage (set DATABASE_URL for PostgreSQL)")
        storage_config = {
            "provider": "sqlite",
            "auto_upgrade_schema": True
        }
    
    # Apply storage to all components
    return storage_config

# Usage in agent factory functions
def get_pagbank_agent(debug_mode: bool = True):
    storage_config = setup_storage_for_components()
    
    return Agent(
        name="PagBank Specialist",
        agent_id="pagbank-specialist",
        storage=create_storage(storage_config),
        debug_mode=debug_mode
        # session_id passed at runtime via API
    )
```

### FastAPI App Integration ✅ COMPLETE PATTERN
```python
# api/serve.py (production pattern)
from agno.app.fastapi.app import FastAPIApp
from agents.orchestrator.main_orchestrator import create_main_orchestrator
from config.postgres_config import get_postgres_storage

def create_pagbank_api():
    """Create production FastAPI app with Agno integration"""
    
    # Create main orchestrator (Ana routing team + specialists)
    orchestrator = create_main_orchestrator()
    
    # Configure storage
    postgres_storage = get_postgres_storage(mode="team")
    if postgres_storage:
        orchestrator.routing_team.storage = postgres_storage
    
    # Create FastAPI app via Agno
    fastapi_app = FastAPIApp(
        teams=[orchestrator.routing_team],  # Main entry point
        name="PagBank Multi-Agent System",
        app_id="pagbank_multiagent",
        description="Sistema multi-agente PagBank com Ana",
        version="2.0.0",
        monitoring=True,  # Enable Agno monitoring
        middleware=[
            metrics_middleware,
            security_headers,
            authentication_middleware
        ]
    )
    
    return fastapi_app

# Create and serve
fastapi_app = create_pagbank_api()
app = fastapi_app.get_app()
```

### Model Configuration Integration ✅ FROM MODEL REFERENCE
```python
# Model configuration with Agno parameter patterns
from agno.models.anthropic import Claude
from agno.models.openai import OpenAI

# Claude configuration (from agno-model-configuration.md)
claude_model = Claude(
    id="claude-sonnet-4-20250514",
    temperature=0.7,
    max_tokens=2000,
    thinking={"type": "enabled", "budget_tokens": 1024},  # ⭐ THINKING MODE
    cache_system_prompt=True,
    api_key=os.getenv("ANTHROPIC_API_KEY")
)

# OpenAI configuration (with reasoning effort)
openai_model = OpenAI(
    id="o3-mini",
    reasoning_effort="medium",  # ⭐ REASONING EFFORT for o3 models
    max_completion_tokens=2000,
    temperature=0.5,
    api_key=os.getenv("OPENAI_API_KEY")
)

# Use in agent factory
def get_pagbank_agent(model_override=None):
    model = model_override or claude_model
    
    return Agent(
        name="PagBank Specialist",
        model=model,
        # ... other config
    )
```

## Performance Optimization ✅ PRODUCTION PATTERNS

### Connection Pooling ✅ FROM REFERENCE PATTERNS
```python
# Agno handles connection pooling automatically, but can be customized
from sqlalchemy.pool import QueuePool
from config.postgres_config import get_postgres_storage

def create_optimized_storage():
    """Create storage with optimized connection pooling"""
    
    # Production-optimized connection pool
    engine = create_engine(
        DATABASE_URL,
        poolclass=QueuePool,
        pool_size=20,              # Base connections
        max_overflow=40,           # Additional connections under load
        pool_pre_ping=True,        # Validate connections
        pool_recycle=3600,         # Recycle connections every hour
        echo=False                 # Disable SQL logging in production
    )
    
    return PostgresStorage(
        engine=engine,
        auto_upgrade_schema=True
    )

# Apply to all agents/teams
def get_pagbank_agent(debug_mode: bool = True):
    storage = create_optimized_storage()
    
    return Agent(
        name="PagBank Specialist",
        storage=storage,
        debug_mode=debug_mode
    )
```

### Response Caching ✅ MULTI-LAYER APPROACH
```python
from fastapi_cache import FastAPICache
from fastapi_cache.decorator import cache
from fastapi_cache.backends.redis import RedisBackend
import redis

# Redis cache for production
if api_settings.runtime_env == "prd":
    redis_client = redis.Redis(
        host=os.getenv("REDIS_HOST", "localhost"),
        port=int(os.getenv("REDIS_PORT", 6379)),
        decode_responses=True
    )
    FastAPICache.init(RedisBackend(), prefix="pagbank-api")

# Agent metadata caching (static information)
@app.get("/v1/agents/{agent_id}/info")
@cache(expire=3600)  # Cache for 1 hour
async def get_agent_info(agent_id: str):
    """Get agent metadata (cached)"""
    agent = get_agent(agent_id)
    return {
        "agent_id": agent.agent_id,
        "name": agent.name,
        "business_unit": get_business_unit(agent_id),
        "available_versions": get_agent_versions(agent_id),
        "capabilities": get_agent_capabilities(agent_id)
    }

# Team configuration caching
@app.get("/v1/teams/{team_id}/config")
@cache(expire=1800)  # Cache for 30 minutes
async def get_team_config(team_id: str):
    """Get team configuration (cached)"""
    team = get_team(team_id)
    return {
        "team_id": team.team_id,
        "name": team.name,
        "mode": team.mode,
        "members": [member.agent_id for member in team.members],
        "routing_keywords": get_routing_keywords(team_id)
    }

# Knowledge base caching (frequently accessed data)
@cache(expire=300)  # Cache for 5 minutes
async def get_cached_knowledge_summary():
    """Get knowledge base summary (cached)"""
    return {
        "total_entries": count_knowledge_entries(),
        "categories": get_knowledge_categories(),
        "last_updated": get_knowledge_last_updated()
    }
```

### Request Optimization ✅ COMPREHENSIVE APPROACH
```python
import asyncio
from functools import wraps

# Async request batching for concurrent operations
class RequestBatcher:
    def __init__(self, batch_size: int = 10, timeout: float = 1.0):
        self.batch_size = batch_size
        self.timeout = timeout
        self.pending_requests = []
    
    async def batch_agent_requests(self, requests: List[dict]):
        """Process multiple agent requests concurrently"""
        semaphore = asyncio.Semaphore(self.batch_size)
        
        async def process_request(request):
            async with semaphore:
                agent = get_agent(request["agent_id"])
                return await agent.arun(
                    messages=request["messages"],
                    session_id=request["session_id"]
                )
        
        # Process all requests concurrently
        tasks = [process_request(req) for req in requests]
        return await asyncio.gather(*tasks, return_exceptions=True)

# Response compression for large payloads
from fastapi.middleware.gzip import GZipMiddleware

app.add_middleware(GZipMiddleware, minimum_size=1000)

# Request timeout middleware
@app.middleware("http")
async def timeout_middleware(request: Request, call_next):
    """Add request timeout protection"""
    try:
        # Longer timeout for agent/team requests, shorter for metadata
        if any(path in request.url.path for path in ["/runs", "/stream"]):
            timeout = 120  # 2 minutes for AI processing
        else:
            timeout = 30   # 30 seconds for metadata/health
        
        return await asyncio.wait_for(call_next(request), timeout=timeout)
    except asyncio.TimeoutError:
        return JSONResponse(
            status_code=408,
            content={
                "error": {
                    "code": "REQUEST_TIMEOUT",
                    "message": f"Request timed out after {timeout}s",
                    "details": {"endpoint": request.url.path}
                }
            }
        )
```

## Key References ✅ COMPREHENSIVE DOCUMENTATION

### Core Framework Integration
- **Agno FastAPI Integration**: `FastAPIApp()` and `Playground()` auto-registration patterns
- **Agent Factories**: `agents/*/agent.py` - YAML-driven factory functions with API parameters
- **Team Orchestration**: `teams/ana/team.py` - Mode="route" routing logic with member selection
- **Workflow Triggers**: `workflows/` - Sequential and parallel workflow execution
- **Storage Integration**: `config/postgres_config.py` - PostgreSQL with SQLite fallback

### Reference Files Extracted
- **Demo App Patterns**: `genie/agno-demo-app/api/` - Router structure and playground integration
- **Agno Parameters**: `genie/reference/agno-components-parameters.md` - Complete parameter reference
- **Model Configuration**: `genie/reference/agno-model-configuration.md` - 20+ model providers
- **YAML vs API**: `genie/reference/yaml-vs-api-parameters.md` - Static vs runtime parameter separation
- **Advanced Patterns**: `genie/reference/agno-advanced-patterns.md` - Tools, knowledge, monitoring

### API Structure Reference
- **Router Hierarchy**: `v1_router` → `playground_router` + `health_router`
- **Endpoint Patterns**: Auto-generated by Agno Playground for agents/teams/workflows
- **Streaming Support**: SSE and WebSocket with Agno's native `run_stream()` methods
- **Error Handling**: Comprehensive error taxonomy with production/development modes
- **Monitoring**: Prometheus metrics + Agno built-in telemetry integration

### Environment Configuration
- **Development**: Full debugging, playground enabled, relaxed security
- **Staging**: Balanced testing environment with production-like setup
- **Production**: Strict security, monitoring enabled, playground disabled
- **Storage**: Automatic PostgreSQL/SQLite detection and failover

## Critical Rules ✅ AGNO-SPECIFIC REQUIREMENTS

### Framework Integration ✅ DO
- ✅ **Use Agno's built-in FastAPI integration** via `FastAPIApp()` and `Playground()`
- ✅ **Follow demo app patterns** from `genie/agno-demo-app/api/` structure
- ✅ **Support dynamic versioning** via API parameters, not file system changes
- ✅ **Implement streaming** using Agno's native `run_stream()` methods
- ✅ **Maintain session continuity** with Agno's automatic session management
- ✅ **Use YAML + API pattern** for static config + runtime parameters
- ✅ **Enable Agno monitoring** with `AGNO_MONITOR="true"` and `AGNO_TELEMETRY="true"`

### Model and Provider ✅ DO
- ✅ **Use Claude thinking mode** with `thinking={"type": "enabled", "budget_tokens": 1024}`
- ✅ **Support 20+ model providers** from agno-model-configuration reference
- ✅ **Handle API key rotation** via environment variables, not hardcoded values
- ✅ **Implement model fallbacks** for high availability (Claude → OpenAI → Groq)

### Business Logic ✅ DO
- ✅ **Route through Ana team** with `mode="route"` for business unit detection
- ✅ **Preserve Portuguese language** in all customer-facing responses
- ✅ **Include compliance validation** for financial operations
- ✅ **Enable human handoff** when frustration detected or explicitly requested

### Security and Performance ✅ DO
- ✅ **Environment-based security** (dev: relaxed, prd: strict)
- ✅ **Rate limiting by endpoint** (agents: 100/min, teams: 200/min, workflows: 20/min)
- ✅ **Comprehensive error handling** with trace IDs and proper taxonomy
- ✅ **Database connection pooling** for production PostgreSQL deployments

### Framework Integration ❌ DON'T
- ❌ **Never hardcode agent configurations** in API code (use YAML + factory pattern)
- ❌ **Never modify core Agno classes** (extend via composition, not inheritance)
- ❌ **Never skip Agno's built-in features** (session management, monitoring, storage)
- ❌ **Never implement custom routing** when `mode="route"` handles it automatically

### Security and Data ❌ DON'T  
- ❌ **Never expose sensitive customer data** in API responses or logs
- ❌ **Never skip authentication** for production endpoints
- ❌ **Never log PII data** (names, documents, account numbers)
- ❌ **Never disable monitoring** in staging/production environments

### Performance and Reliability ❌ DON'T
- ❌ **Never block async operations** with synchronous calls
- ❌ **Never skip timeout protection** for external API calls
- ❌ **Never disable connection pooling** in production PostgreSQL
- ❌ **Never ignore error categorization** (use proper error codes and messages)

## Review Task for Context Transfer ✅ COMPREHENSIVE VALIDATION

### Content Verification Checklist - API Layer Domain
**Before proceeding to tests/CLAUDE.md, validate this api/ documentation:**

#### ✅ Core API Patterns Documented
1. ✅ **Agno-first FastAPI integration** with automatic endpoint generation via Playground
2. ✅ **Dynamic agent versioning** support without file system changes
3. ✅ **Streaming implementation** using Agno's native `run_stream()` methods for SSE and WebSocket
4. ✅ **Environment-based configuration** (dev, staging, production) with security scaling
5. ✅ **Comprehensive error handling** with proper taxonomy and trace IDs
6. ✅ **Rate limiting and security** patterns with API key authentication
7. ✅ **Performance optimization** including caching, connection pooling, and request batching

#### ✅ Cross-Reference Validation with Other CLAUDE.md Files
- **agents/CLAUDE.md**: API endpoints should support all documented agent factory parameters
- **teams/CLAUDE.md**: Team routing endpoints should handle all documented modes and configurations
- **workflows/CLAUDE.md**: Workflow endpoints should support documented execution patterns and streaming
- **config/CLAUDE.md**: API configuration should align with global environment and security settings
- **db/CLAUDE.md**: Database dependencies and health checks should match documented patterns
- **tests/CLAUDE.md**: API testing patterns should cover all documented endpoints and security features

#### ✅ Missing Content Identification
**Content that should be transferred TO other CLAUDE.md files:**
- API testing patterns → Transfer to `tests/CLAUDE.md`
- Database FastAPI dependencies → Already documented in `db/CLAUDE.md` ✅
- Global API configuration → Already documented in `config/CLAUDE.md` ✅
- Agent endpoint requirements → Already documented in `agents/CLAUDE.md` ✅

**Content that should be transferred FROM other CLAUDE.md files:**
- Agent factory patterns FROM `agents/CLAUDE.md` ✅ Already integrated
- Team routing patterns FROM `teams/CLAUDE.md` ✅ Already integrated
- Database health patterns FROM `db/CLAUDE.md` ✅ Already integrated
- ❌ No other API-specific content found requiring transfer here

#### ✅ Duplication Prevention
**Content properly separated to avoid overlap:**
- ✅ API layer patterns documented here, NOT scattered across component files
- ✅ FastAPI integration here, NOT duplicated in agent/team files
- ✅ Endpoint documentation here, NOT repeated in individual component files
- ✅ Security and rate limiting here, NOT mixed with business logic

#### ✅ Context Transfer Requirements for Future Development
**Essential API context that must be preserved:**
1. **Agno-First Architecture**: All endpoints auto-generated via Playground, not manual FastAPI routes
2. **Dynamic Versioning**: API parameters for version control, not file system changes
3. **Streaming Support**: Real-time responses using Agno's native streaming capabilities
4. **Environment Scaling**: Development convenience to production security with proper scaling
5. **Error Consistency**: Comprehensive error taxonomy with proper categorization and trace IDs
6. **Performance First**: Built-in caching, batching, and optimization for high-load scenarios

#### ✅ Integration Validation Requirements
**Validate these integration points when implementing:**
- **API → Agent Integration**: Verify all agent factory parameters are supported via endpoints
- **API → Team Integration**: Confirm team routing modes work correctly through API
- **API → Workflow Integration**: Test workflow execution and streaming through endpoints
- **API → Database Integration**: Validate health checks and dependency patterns
- **API → Config Integration**: Ensure environment configurations scale properly
- **API → Testing Integration**: Confirm all endpoints and security features are testable

### ✅ Content Successfully Organized in api/CLAUDE.md
- ✅ **Agno FastAPI Integration**: Complete playground and auto-registration patterns
- ✅ **Dynamic Agent Management**: Version control and parameter handling without file changes
- ✅ **Streaming Architecture**: SSE and WebSocket implementation with native Agno support
- ✅ **Security Framework**: Environment-based authentication, rate limiting, and CORS
- ✅ **Error Management**: Comprehensive taxonomy with production and development modes
- ✅ **Performance Optimization**: Caching, batching, and connection pooling patterns
- ✅ **Monitoring Integration**: Prometheus metrics and health check implementations

### ✅ Key API Extractions from Reference Files
1. ✅ **Demo App API Structure**: Router hierarchy, playground integration, health checks
2. ✅ **Agno Parameters**: Complete agent/team/workflow parameter reference integration
3. ✅ **Model Configuration**: 20+ provider support with specific parameters and features
4. ✅ **Advanced Patterns**: Tools, monitoring, environment variables integration
5. ✅ **YAML vs API Separation**: Static configuration vs runtime parameter patterns
6. ✅ **Streaming Implementation**: Server-Sent Events and WebSocket with Agno native support
7. ✅ **Security Patterns**: Environment-based auth, rate limiting, CORS configuration
8. ✅ **Error Handling**: Comprehensive error taxonomy and production-ready handlers
9. ✅ **Monitoring**: Prometheus metrics, health checks, performance tracking
10. ✅ **Integration Patterns**: Complete Agno FastAPI integration with PostgreSQL/SQLite storage

### ✅ Validation Completed - Ready for tests/CLAUDE.md Review

**Structure Maintained**: Following consistent pattern across all CLAUDE.md files for seamless context transfer

**Focus**: API-specific patterns that support the entire PagBank multi-agent ecosystem with emphasis on Agno framework integration, dynamic versioning, streaming responses, and production-ready deployment patterns.