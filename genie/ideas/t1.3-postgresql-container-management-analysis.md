# T1.3: PostgreSQL Container Management - Implementation Analysis

## 🎯 TASK CONTEXT

**Reference**: @uvx-phase-1-foundation.md#T1.3
**Dependencies**: T1.2 (credential management) - COMPLETED ✅

**LEVERAGE STRENGTH**: Excellent Docker PostgreSQL foundation already exists in docker-compose.yml and Makefile.

## 🔍 CURRENT FOUNDATION ANALYSIS

### Existing Docker PostgreSQL Excellence
```yaml
# docker-compose.yml - PRODUCTION-READY FOUNDATION
postgres:
  image: agnohq/pgvector:16          # ✅ Correct pgvector image
  container_name: hive-postgres      # ✅ Named container
  restart: unless-stopped            # ✅ Auto-restart policy
  user: "${POSTGRES_UID:-1000}:${POSTGRES_GID:-1000}"  # ✅ Cross-platform UID/GID
  environment:
    - POSTGRES_USER                  # ✅ From env variables
    - POSTGRES_PASSWORD              # ✅ Secure credentials
    - POSTGRES_DB=hive               # ✅ Database name
    - PGDATA=/var/lib/postgresql/data/pgdata  # ✅ Data directory
  volumes:
    - ./data/postgres:/var/lib/postgresql/data  # ✅ Persistence
  command:                           # ✅ Performance optimization
    postgres
    -c max_connections=200
    -c shared_buffers=256MB
    -c effective_cache_size=1GB
  ports:
    - "5532:5432"                   # ✅ External port 5532
  networks:
    - app_network                   # ✅ Bridge network
  healthcheck:                      # ✅ Health validation
    test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER:-ai}"]
    interval: 10s
    timeout: 5s
    retries: 5
```

### Existing Makefile Excellence
```bash
# setup_docker_postgres function - COMPREHENSIVE FOUNDATION
- ✅ Interactive PostgreSQL setup with user choice
- ✅ Docker availability checking with check_docker
- ✅ Secure credential generation via generate_postgres_credentials
- ✅ Cross-platform UID/GID handling (Linux/macOS/Windows/WSL)
- ✅ Data directory permissions fixing
- ✅ URL parsing and environment variable extraction
- ✅ Container startup with docker-compose
- ✅ Success feedback and next steps guidance
```

### Existing Credential Integration (T1.2 COMPLETED)
```python
# lib/auth/credential_service.py - READY FOR INTEGRATION
- ✅ generate_postgres_credentials() - Secure PostgreSQL credentials
- ✅ extract_postgres_credentials_from_env() - Parse existing credentials  
- ✅ Cross-platform secure random generation
- ✅ Database URL construction: postgresql+psycopg://user:pass@localhost:5532/hive
- ✅ Environment file management (.env creation and updates)
- ✅ Validation and format checking
```

## 🎯 CLI INTEGRATION REQUIREMENTS

### Container Lifecycle Management
```python
# CLI Commands to Implement
uvx automagik-hive --init                    # Setup PostgreSQL during workspace init
uvx automagik-hive ./my-workspace            # Start workspace with PostgreSQL validation
uvx automagik-hive --postgres-status         # Check PostgreSQL container health
uvx automagik-hive --postgres-restart        # Restart PostgreSQL container
uvx automagik-hive --postgres-logs           # Stream PostgreSQL logs
uvx automagik-hive --postgres-stop           # Stop PostgreSQL container
```

### Integration Architecture
```python
# CLI Module Structure (to be created)
cli/
├── core/
│   ├── docker_service.py          # Docker operations service
│   └── postgres_service.py        # PostgreSQL-specific operations
├── commands/
│   ├── init.py                    # --init command (uses PostgreSQL setup)
│   ├── workspace.py               # ./workspace command (validates PostgreSQL)
│   └── postgres.py                # --postgres-* commands
└── domain/
    └── container_manager.py       # Container lifecycle management
```

## 🔧 IMPLEMENTATION STRATEGY

### Phase 1: Extract Makefile Logic to Python
```python
# lib/docker/postgres_manager.py (NEW)
class PostgreSQLManager:
    """
    Container lifecycle management for PostgreSQL with pgvector.
    Replicates setup_docker_postgres Makefile functionality.
    """
    
    def __init__(self, credential_service: CredentialService):
        self.credential_service = credential_service
        self.container_name = "hive-postgres"
        self.image = "agnohq/pgvector:16"
        self.external_port = 5532
        self.internal_port = 5432
        
    def setup_postgres_container(self, interactive: bool = True) -> bool:
        """Replicate setup_docker_postgres function"""
        
    def check_container_status(self) -> ContainerStatus:
        """Check if PostgreSQL container is running and healthy"""
        
    def start_container(self) -> bool:
        """Start PostgreSQL container with existing docker-compose.yml"""
        
    def stop_container(self) -> bool:
        """Stop PostgreSQL container gracefully"""
        
    def restart_container(self) -> bool:
        """Restart PostgreSQL container"""
        
    def get_container_logs(self, tail: int = 50) -> str:
        """Get PostgreSQL container logs"""
        
    def validate_container_health(self) -> bool:
        """Validate PostgreSQL is accepting connections"""
```

### Phase 2: Docker Compose Integration
```python
# lib/docker/compose_manager.py (NEW)
class DockerComposeManager:
    """
    Docker Compose orchestration for PostgreSQL container.
    Uses existing docker-compose.yml as foundation.
    """
    
    def __init__(self):
        self.compose_file = "docker-compose.yml"
        self.postgres_service = "postgres"
        
    def start_postgres_service(self) -> bool:
        """Start only PostgreSQL service from docker-compose.yml"""
        # docker-compose up -d postgres
        
    def stop_postgres_service(self) -> bool:
        """Stop PostgreSQL service"""
        # docker-compose stop postgres
        
    def restart_postgres_service(self) -> bool:
        """Restart PostgreSQL service"""
        # docker-compose restart postgres
        
    def get_service_logs(self, service: str, tail: int = 50) -> str:
        """Get logs for specific service"""
        # docker-compose logs -f --tail={tail} {service}
        
    def check_service_health(self, service: str) -> bool:
        """Check service health via docker-compose"""
        # docker-compose ps {service}
```

### Phase 3: CLI Command Integration
```python
# cli/commands/postgres.py (NEW)
@app.command()
def postgres_status():
    """Check PostgreSQL container status and health"""
    
@app.command()
def postgres_start():
    """Start PostgreSQL container"""
    
@app.command()
def postgres_stop():
    """Stop PostgreSQL container"""
    
@app.command()
def postgres_restart():
    """Restart PostgreSQL container"""
    
@app.command()
def postgres_logs(tail: int = 50):
    """Show PostgreSQL container logs"""
```

### Phase 4: Workspace Integration
```python
# Integration with --init and ./workspace commands

# cli/commands/init.py
def initialize_workspace(path: str):
    """
    Initialize workspace with PostgreSQL setup
    - Generate credentials via CredentialService (T1.2)
    - Create docker-compose.yml from template
    - Setup PostgreSQL container via PostgreSQLManager
    - Validate container health
    """
    
# cli/commands/workspace.py  
def start_workspace(path: str):
    """
    Start workspace with PostgreSQL validation
    - Validate .env file exists with database credentials
    - Check PostgreSQL container status
    - Start PostgreSQL if not running
    - Validate database connectivity
    - Start main application server
    """
```

## 🔄 CROSS-PLATFORM COMPATIBILITY

### UID/GID Handling (from Makefile)
```python
def get_postgres_uid_gid() -> Tuple[int, int]:
    """
    Cross-platform UID/GID determination for PostgreSQL container.
    Replicates Makefile logic for Linux/macOS/Windows/WSL.
    """
    if platform.system() in ["Linux", "Darwin"]:
        return os.getuid(), os.getgid()
    else:  # Windows/WSL
        return 1000, 1000
```

### Data Directory Permissions
```python
def fix_postgres_data_permissions(data_dir: Path) -> bool:
    """
    Fix PostgreSQL data directory permissions.
    Replicates Makefile permission fixing logic.
    """
    if data_dir.exists():
        if platform.system() in ["Linux", "Darwin"]:
            # Check if owned by root and fix
            stat_info = data_dir.stat()
            if stat_info.st_uid == 0:  # root owned
                uid, gid = get_postgres_uid_gid()
                shutil.chown(data_dir, uid, gid)
```

## 🧪 INTEGRATION VALIDATION

### Health Check System
```python
def validate_postgres_integration() -> ValidationResult:
    """
    Comprehensive PostgreSQL integration validation:
    - Docker daemon running
    - Container exists and is healthy
    - PostgreSQL accepting connections
    - Database accessible with credentials
    - pgvector extension available
    """
```

### Error Handling Strategy
```python
class PostgreSQLIntegrationError(Exception):
    """PostgreSQL container integration errors"""
    
class DockerNotAvailableError(PostgreSQLIntegrationError):
    """Docker daemon not available or not running"""
    
class ContainerStartupError(PostgreSQLIntegrationError):
    """PostgreSQL container failed to start"""
    
class DatabaseConnectionError(PostgreSQLIntegrationError):
    """Cannot connect to PostgreSQL database"""
```

## 📊 SUCCESS CRITERIA

### T1.3 Completion Criteria
- ✅ **CLI Integration**: PostgreSQL container lifecycle managed through CLI commands
- ✅ **Makefile Replication**: All setup_docker_postgres functionality preserved
- ✅ **Credential Integration**: Seamless integration with T1.2 credential management
- ✅ **Health Checking**: Comprehensive container and database health validation
- ✅ **Cross-Platform**: Works on Linux/macOS/Windows/WSL with proper UID/GID handling
- ✅ **Error Handling**: Graceful failure handling with clear user guidance
- ✅ **Docker Compose**: Uses existing docker-compose.yml as foundation
- ✅ **Performance**: Maintains existing container performance optimizations

### Integration Points Validated
- ✅ **T1.2 Dependency**: Uses CredentialService for secure credential generation
- ✅ **Docker Foundation**: Leverages existing docker-compose.yml excellence
- ✅ **Makefile Compatibility**: Preserves all existing Makefile functionality
- ✅ **UVX Compatibility**: All Docker operations work within UVX environment

## 🚀 IMPLEMENTATION PRIORITIES

1. **High Priority**: Extract setup_docker_postgres logic to Python classes
2. **High Priority**: Create PostgreSQLManager with container lifecycle methods
3. **Medium Priority**: Implement CLI command structure for --postgres-* commands
4. **Medium Priority**: Integrate with --init and ./workspace commands
5. **Low Priority**: Add advanced monitoring and performance metrics

This analysis provides the complete roadmap for T1.3 implementation, leveraging the excellent existing Docker PostgreSQL foundation while adding CLI integration capabilities required for the UVX transformation.