"""
Mock LLM implementation for performance testing without API costs.
Simulates realistic response times and behaviors.
"""

import time
import random
from typing import Dict, List, Optional, Any
from dataclasses import dataclass


@dataclass
class MockResponse:
    """Mock LLM response structure."""
    content: str
    usage: Dict[str, int]
    model: str
    finish_reason: str = "stop"


class MockLLM:
    """Mock LLM that simulates real API behavior without costs."""
    
    def __init__(self, 
                 model_name: str = "mock-claude-sonnet-4",
                 base_latency: float = 2.0,
                 latency_variance: float = 1.0,
                 failure_rate: float = 0.02):
        """
        Initialize mock LLM.
        
        Args:
            model_name: Name of the mock model
            base_latency: Base response time in seconds
            latency_variance: Random variance in response time
            failure_rate: Probability of API failure (0.0-1.0)
        """
        self.model_name = model_name
        self.base_latency = base_latency
        self.latency_variance = latency_variance
        self.failure_rate = failure_rate
        
        # Pre-generated responses for different agent types
        self.agent_responses = {
            'pagbank-specialist': [
                "Ol√°! Posso te ajudar com PIX sim! Para fazer uma transfer√™ncia PIX, voc√™ precisa:\n\n1. Abrir o app PagBank\n2. Ir em 'PIX' no menu principal\n3. Escolher 'Enviar PIX'\n4. Inserir a chave PIX do destinat√°rio\n5. Confirmar o valor e finalizar\n\nO PIX √© instant√¢neo e funciona 24h por dia, 7 dias por semana! Alguma d√∫vida espec√≠fica sobre PIX?",
                
                "Sobre transfer√™ncias no PagBank:\n\nüí∞ **PIX**: Instant√¢neo, sem taxa, 24h\nüí≥ **TED**: At√© R$ 1.000 gr√°tis, hor√°rio banc√°rio\nüìÑ **DOC**: At√© R$ 5.000, processado no dia √∫til\n\nPara fazer qualquer transfer√™ncia:\n1. Acesse 'Transferir' no app\n2. Escolha o tipo (PIX, TED, DOC)\n3. Insira os dados do destinat√°rio\n4. Confirme com sua senha\n\nPrecisa de ajuda com algum tipo espec√≠fico?",
                
                "Seu limite PIX pode ser consultado em:\n\nüì± **No app**: Menu > PIX > Meus limites\n‚è∞ **Limites padr√£o**:\n- PIX diurno: R$ 20.000\n- PIX noturno: R$ 1.000\n- TED: R$ 50.000\n\nPara aumentar limites:\n1. V√° em 'Configura√ß√µes'\n2. Selecione 'Limites'\n3. Solicite aumento\n4. Aguarde aprova√ß√£o (at√© 24h)\n\nQuer saber sobre algum limite espec√≠fico?"
            ],
            
            'adquirencia-specialist': [
                "Sobre antecipa√ß√£o de vendas no PagBank:\n\nüí∞ **Como funciona**:\n- Voc√™ recebe hoje o valor das suas vendas futuras\n- Taxa competitiva a partir de 2,5% ao m√™s\n- Dispon√≠vel para cart√£o de cr√©dito e d√©bito\n\nüìã **Requisitos**:\n- Hist√≥rico de vendas m√≠nimo de 30 dias\n- Conta regularizada\n- Vendas eleg√≠veis dispon√≠veis\n\nüîÑ **Como solicitar**:\n1. Acesse 'Antecipa√ß√£o' no app\n2. Veja suas vendas eleg√≠veis\n3. Escolha o valor a antecipar\n4. Confirme a opera√ß√£o\n\nQuer simular uma antecipa√ß√£o?",
                
                "Sobre multiadquir√™ncia:\n\nüè™ **Benef√≠cios**:\n- Concentre vendas de v√°rias maquininhas\n- Vis√£o unificada do faturamento\n- Antecipa√ß√£o de todas as vendas\n\n‚öôÔ∏è **Como configurar**:\n1. Cadastre outras adquirentes no app\n2. Informe dados das maquininhas\n3. Aguarde integra√ß√£o (2-3 dias √∫teis)\n4. Acompanhe tudo em um lugar\n\nüìä **Relat√≥rios dispon√≠veis**:\n- Vendas por adquirente\n- Comparativo de taxas\n- An√°lise de performance\n\nPrecisa cadastrar alguma adquirente?"
            ],
            
            'emissao-specialist': [
                "Sobre limites de cart√£o no PagBank:\n\nüí≥ **Consultar limite atual**:\n- App PagBank > Cart√£o > Limite dispon√≠vel\n- Ou ligue para 0800 887 0023\n\nüìà **Aumentar limite**:\n1. Acesse 'Cart√£o' no app\n2. Toque em 'Solicitar aumento'\n3. Informe renda atualizada\n4. Envie comprovantes se solicitado\n5. Aguarde an√°lise (at√© 5 dias √∫teis)\n\n‚úÖ **Dicas para aprova√ß√£o**:\n- Mantenha conta movimentada\n- Quite faturas em dia\n- Atualize dados de renda\n- Use o cart√£o regularmente\n\nQual limite voc√™ gostaria de solicitar?",
                
                "Sobre desbloqueio de cart√£o:\n\nüîì **Como desbloquear**:\n1. Abra o app PagBank\n2. V√° em 'Cart√£o'\n3. Toque em 'Desbloquear'\n4. Confirme com sua senha\n\nüÜò **Se n√£o conseguir pelo app**:\n- Ligue 0800 887 0023\n- Tenha em m√£os: CPF, data de nascimento\n- Informe √∫ltimas movimenta√ß√µes\n\nüîí **Motivos de bloqueio**:\n- Tentativas de senha incorreta\n- Suspeita de fraude\n- Cart√£o vencido\n- Solicita√ß√£o do cliente\n\nSeu cart√£o est√° bloqueado por qual motivo?"
            ]
        }
    
    def _simulate_latency(self):
        """Simulate realistic API latency."""
        latency = self.base_latency + random.uniform(-self.latency_variance, self.latency_variance)
        latency = max(0.1, latency)  # Minimum 100ms
        time.sleep(latency)
    
    def _should_fail(self) -> bool:
        """Determine if this request should fail."""
        return random.random() < self.failure_rate
    
    def _get_response_for_agent(self, agent_id: str, message: str) -> str:
        """Get appropriate response for agent type."""
        # Extract agent type from agent_id
        agent_type = agent_id.split('-')[0] if '-' in agent_id else agent_id
        
        if agent_type in self.agent_responses:
            responses = self.agent_responses[agent_type]
            # Choose response based on message content
            if any(keyword in message.lower() for keyword in ['pix', 'transfer√™ncia', 'enviar']):
                return responses[0]
            elif any(keyword in message.lower() for keyword in ['limite', 'aumentar']):
                return responses[-1]
            else:
                return random.choice(responses)
        
        # Default response for unknown agent types
        return f"Ol√°! Sou um assistente virtual e posso te ajudar com suas d√∫vidas sobre {agent_type}. Como posso te ajudar hoje?"
    
    def generate_response(self, message: str, agent_id: str = "generic") -> MockResponse:
        """
        Generate mock response for a message.
        
        Args:
            message: Input message
            agent_id: Agent identifier to customize response
            
        Returns:
            MockResponse with generated content
            
        Raises:
            Exception: If simulated failure occurs
        """
        # Simulate network latency
        self._simulate_latency()
        
        # Simulate occasional failures
        if self._should_fail():
            error_messages = [
                "Rate limit exceeded. Please try again later.",
                "Service temporarily unavailable.",
                "Authentication failed.",
                "Invalid request format.",
                "Model overloaded. Please retry."
            ]
            raise Exception(random.choice(error_messages))
        
        # Generate appropriate response
        content = self._get_response_for_agent(agent_id, message)
        
        # Simulate token usage
        input_tokens = len(message.split()) * 1.3  # Approximate tokenization
        output_tokens = len(content.split()) * 1.3
        
        return MockResponse(
            content=content,
            usage={
                "input_tokens": int(input_tokens),
                "output_tokens": int(output_tokens),
                "total_tokens": int(input_tokens + output_tokens)
            },
            model=self.model_name,
            finish_reason="stop"
        )


class MockClaudeModel:
    """Mock Claude model that can be used as a drop-in replacement."""
    
    def __init__(self, 
                 id: str = "mock-claude-sonnet-4",
                 temperature: float = 0.7,
                 max_tokens: int = 2000):
        self.id = id
        self.temperature = temperature
        self.max_tokens = max_tokens
        self.mock_llm = MockLLM(model_name=id)
    
    def __call__(self, messages: List[Dict[str, str]], **kwargs) -> str:
        """Process messages and return response."""
        # Extract the last user message
        user_message = ""
        agent_id = "generic"
        
        for message in messages:
            if message.get("role") == "user":
                user_message = message.get("content", "")
            elif message.get("role") == "system":
                # Try to extract agent type from system message
                content = message.get("content", "").lower()
                if "pagbank" in content:
                    agent_id = "pagbank-specialist"
                elif "adquirencia" in content or "antecipa√ß√£o" in content:
                    agent_id = "adquirencia-specialist"
                elif "emissao" in content or "cart√£o" in content:
                    agent_id = "emissao-specialist"
        
        # Generate response
        response = self.mock_llm.generate_response(user_message, agent_id)
        return response.content


class MockAnthropicAPI:
    """Mock Anthropic API for testing."""
    
    @staticmethod
    def patch_claude_model():
        """Patch the Claude model to use mock implementation."""
        try:
            # Try to patch the actual Claude model
            from agno.models.anthropic import Claude
            
            # Store original __call__ method
            if not hasattr(Claude, '_original_call'):
                Claude._original_call = Claude.__call__
            
            # Replace with mock
            def mock_call(self, messages, **kwargs):
                mock_model = MockClaudeModel(id=self.id, temperature=getattr(self, 'temperature', 0.7))
                return mock_model(messages, **kwargs)
            
            Claude.__call__ = mock_call
            print("‚úÖ Claude model patched with mock implementation")
            
        except ImportError:
            print("‚ö†Ô∏è Could not patch Claude model - import failed")
    
    @staticmethod
    def restore_claude_model():
        """Restore original Claude model."""
        try:
            from agno.models.anthropic import Claude
            
            if hasattr(Claude, '_original_call'):
                Claude.__call__ = Claude._original_call
                delattr(Claude, '_original_call')
                print("‚úÖ Claude model restored to original implementation")
            
        except ImportError:
            print("‚ö†Ô∏è Could not restore Claude model - import failed")


# Context manager for mock testing
class MockLLMContext:
    """Context manager for mock LLM testing."""
    
    def __init__(self, enable_mock: bool = True):
        self.enable_mock = enable_mock
    
    def __enter__(self):
        if self.enable_mock:
            MockAnthropicAPI.patch_claude_model()
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.enable_mock:
            MockAnthropicAPI.restore_claude_model()


# Environment variable support
def should_use_mock_llm() -> bool:
    """Check if mock LLM should be used based on environment."""
    import os
    return os.getenv("USE_MOCK_LLM", "false").lower() in ("true", "1", "yes")


# Auto-patch if environment variable is set
if should_use_mock_llm():
    MockAnthropicAPI.patch_claude_model()
    print("ü§ñ Mock LLM enabled via environment variable")


if __name__ == "__main__":
    # Test the mock LLM
    print("üß™ Testing Mock LLM")
    
    mock_llm = MockLLM()
    
    test_messages = [
        ("pagbank-specialist", "Como fazer um PIX?"),
        ("adquirencia-specialist", "Como funciona a antecipa√ß√£o?"),
        ("emissao-specialist", "Qual o limite do cart√£o?")
    ]
    
    for agent_id, message in test_messages:
        print(f"\nüìù Testing {agent_id}: {message}")
        try:
            response = mock_llm.generate_response(message, agent_id)
            print(f"‚úÖ Response: {response.content[:100]}...")
            print(f"üìä Tokens: {response.usage['total_tokens']}")
        except Exception as e:
            print(f"‚ùå Error: {e}")